import { Component, Input, Output, EventEmitter, ViewChild } from '@angular/core';
import { NgForm } from '@angular/forms';

import { Configuration } from '../config';
import { VULNERABILITY_CONFIG_HTML, VULNERABILITY_CONFIG_STYLES } from './vulnerability-config.component.template';
import { ScanningResultService } from '../../service/scanning.service';
import { ErrorHandler } from '../../error-handler';
import { toPromise } from '../../utils';
import { TranslateService } from '@ngx-translate/core';

const ONE_HOUR_SECONDS: number = 3600;
const ONE_DAY_SECONDS: number = 24 * ONE_HOUR_SECONDS;

@Component({
    selector: 'vulnerability-config',
    template: VULNERABILITY_CONFIG_HTML,
    styles: [VULNERABILITY_CONFIG_STYLES]
})
export class VulnerabilityConfigComponent {
    _localTime: Date = new Date();

    config: Configuration;
    @Output() configChange: EventEmitter<Configuration> = new EventEmitter<Configuration>();

    @Input()
    get vulnerabilityConfig(): Configuration {
        return this.config;
    }
    set vulnerabilityConfig(cfg: Configuration) {
        this.config = cfg;
        if (this.config.scan_all_policy &&
            this.config.scan_all_policy.value) {
            if (this.config.scan_all_policy.value.type === "daily") {
                if (!this.config.scan_all_policy.value.parameter) {
                    this.config.scan_all_policy.value.parameter = {
                        daily_time: 0
                    };
                }
            }
        }
        this.configChange.emit(this.config);
    }

    //UTC time
    get dailyTime(): string {
        if (!(this.config &&
            this.config.scan_all_policy &&
            this.config.scan_all_policy.value &&
            this.config.scan_all_policy.value.type === "daily")) {
            return "00:00";
        }

        let timeOffset: number = 0;//seconds
        if (this.config.scan_all_policy.value.parameter) {
            let daily_time = this.config.scan_all_policy.value.parameter.daily_time;
            if (daily_time && typeof daily_time === "number") {
                timeOffset = +daily_time;
            }
        }

        //Convert to current time
        let timezoneOffset: number = this._localTime.getTimezoneOffset();
        //Local time
        timeOffset = timeOffset - timezoneOffset * 60;
        if (timeOffset < 0) {
            timeOffset = timeOffset + ONE_DAY_SECONDS;
        }

        if (timeOffset >= ONE_DAY_SECONDS) {
            timeOffset -= ONE_DAY_SECONDS;
        }

        //To time string
        let hours: number = Math.floor(timeOffset / ONE_HOUR_SECONDS);
        let minutes: number = Math.floor((timeOffset - hours * ONE_HOUR_SECONDS) / 60);

        let timeStr: string = "" + hours;
        if (hours < 10) {
            timeStr = "0" + timeStr;
        }
        if (minutes < 10) {
            timeStr += ":0";
        } else {
            timeStr += ":";
        }
        timeStr += minutes;

        return timeStr;
    }
    set dailyTime(v: string) {
        if (!v || v === "") {
            return;
        }

        if (!(this.config &&
            this.config.scan_all_policy &&
            this.config.scan_all_policy.value &&
            this.config.scan_all_policy.value.type === "daily")) {
            return;
        }

        //Double confirm inner parameter existing.
        if (!this.config.scan_all_policy.value.parameter) {
            this.config.scan_all_policy.value.parameter = {
                daily_time: 0
            };
        }

        let values: string[] = v.split(":");
        if (!values || values.length !== 2) {
            return;
        }

        let hours: number = +values[0];
        let minutes: number = +values[1];
        //Convert to UTC time
        let timezoneOffset: number = this._localTime.getTimezoneOffset();
        let utcTimes: number = hours * ONE_HOUR_SECONDS + minutes * 60;
        utcTimes += timezoneOffset * 60;
        if (utcTimes < 0) {
            utcTimes += ONE_DAY_SECONDS;
        }

        if (utcTimes >= ONE_DAY_SECONDS) {
            utcTimes -= ONE_DAY_SECONDS;
        }

        this.config.scan_all_policy.value.parameter.daily_time = utcTimes;
    }

    //Scanning type
    get scanningType(): string {
        if (this.config &&
            this.config.scan_all_policy &&
            this.config.scan_all_policy.value) {
            return this.config.scan_all_policy.value.type;
        } else {
            //default
            return "none";
        }
    }

    set scanningType(v: string) {
        if (this.config &&
            this.config.scan_all_policy &&
            this.config.scan_all_policy.value) {
            let type: string = (v && v.trim() !== "") ? v : "none";
            this.config.scan_all_policy.value.type = type;
            if (type !== "daily") {
                //No parameter
                if (this.config.scan_all_policy.value.parameter) {
                    delete (this.config.scan_all_policy.value.parameter);
                }
            } else {
                //Has parameter
                if (!this.config.scan_all_policy.value.parameter) {
                    this.config.scan_all_policy.value.parameter = {
                        daily_time: 0
                    };
                }
            }
        }
    }

    @ViewChild("systemConfigFrom") systemSettingsForm: NgForm;

    get editable(): boolean {
        return this.vulnerabilityConfig &&
            this.vulnerabilityConfig.scan_all_policy &&
            this.vulnerabilityConfig.scan_all_policy.editable;
    }

    get isValid(): boolean {
        return this.systemSettingsForm && this.systemSettingsForm.valid;
    }

    get showTimePicker(): boolean {
        return this.vulnerabilityConfig &&
            this.vulnerabilityConfig.scan_all_policy &&
            this.vulnerabilityConfig.scan_all_policy.value &&
            this.vulnerabilityConfig.scan_all_policy.value.type === "daily";
    }

    constructor(
        private scanningService: ScanningResultService,
        private errorHandler: ErrorHandler,
        private translate: TranslateService) { }

    scanNow(): void {
        toPromise<any>(this.scanningService.startScanningAll())
            .then(() => {
                this.translate.get("CONFIG.SCANNING.TRIGGER_SCAN_ALL_SUCCESS").subscribe((res: string) => {
                    this.errorHandler.info(res);
                });
                //TODO:
                //Change button disable status.
            })
            .catch(error => this.errorHandler.error(error))
    }
}